1. 先寫一個各種產品類別的推薦程式：
```C#
public class ProductRecommender{
	public List<string> recommender(string category){
		List<string> products=new List<string>();
		
		if(category=="phone"){
			recommenderPhone(products);
		}
		else if(category=="television"){
			recommenderTelevision(products);
		}
		else if(category=="notebook"){
			recommenderNotebook(products);
		}
		else{
			throw new Exception();
		}

		return products;
	}

	private void recommenderPhone(List<string> products){
		products.Add("A");
		products.Add("B");
		products.Add("C");
	}
	
	private void recommenderTelevision(List<string> products){
		products.Add("A");
		products.Add("B");
		products.Add("C");
	}

	private void recommenderNotebook(List<string> products){
		products.Add("A");
		products.Add("B");
		products.Add("C");
	}
}
```

> 以上`ProductRecommender`類別的`recommender`，包含了各種不同商品的推薦程式邏輯，違反`單一職責原則`的設計原則

2. 為了調整為`單一職責原則`的設計原則，需將各種產品類別的推薦程式，各別寫一個類別去做維護：
```C#
public class PhoneRecommender{
	public List<string> recommender(string category){
		List<string> products=new List<string>();
		
		products.Add("A");
		products.Add("B");
		products.Add("C");

		return products;
	}
}
```

```C#
public class TelevisionRecommender{
	public List<string> recommender(string category){
		List<string> products=new List<string>();
		
		products.Add("A");
		products.Add("B");
		products.Add("C");

		return products;
	}
}
```

```C#
public class NotebookRecommender{
	public List<string> recommender(string category){
		List<string> products=new List<string>();
		
		products.Add("A");
		products.Add("B");
		products.Add("C");

		return products;
	}
}
```

3. 假設後續又新增一個產品要撰寫推薦功能，那只要再新增一個類別即可，這樣就能符合`開閉原則`